Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ADDRESS
    AND
    ARROW
    AUTO
    BITWISE_AND
    BITWISE_NOT
    BITWISE_OR
    BITWISE_XOR
    BOOL
    BREAK
    CASE
    CHAR
    CHAR_LITERAL
    COLON
    COMMA
    CONST
    CONTINUE
    DECREMENT
    DEFAULT
    DEREFERENCE
    DIVIDE
    DIVIDE_ASSIGN
    DO
    DOT
    DOUBLE
    ELSE
    EQ
    EXTERN
    FLOAT
    FLOAT_NUM
    FOR
    FREE
    GE
    GT
    IF
    INCREMENT
    LBRACE
    LBRACKET
    LE
    LONG
    LPAREN
    LSHIFT
    LT
    MALLOC
    MINUS
    MINUS_ASSIGN
    MODULO
    NE
    NOT
    OR
    PLUS
    PLUS_ASSIGN
    PRINTF
    QUESTION
    RBRACE
    RBRACKET
    REGISTER
    RETURN
    RPAREN
    RSHIFT
    SCANF
    SHORT
    SIGNED
    SIZEOF
    STATIC
    STRING_LITERAL
    SWITCH
    TIMES
    TIMES_ASSIGN
    UNSIGNED
    VOID
    VOLATILE
    WHILE

Grammar

Rule 0     S' -> test
Rule 1     test -> INT IDENTIFIER ASSIGN NUMBER SEMICOLON

Terminals, with rules where they appear

ADDRESS              : 
AND                  : 
ARROW                : 
ASSIGN               : 1
AUTO                 : 
BITWISE_AND          : 
BITWISE_NOT          : 
BITWISE_OR           : 
BITWISE_XOR          : 
BOOL                 : 
BREAK                : 
CASE                 : 
CHAR                 : 
CHAR_LITERAL         : 
COLON                : 
COMMA                : 
CONST                : 
CONTINUE             : 
DECREMENT            : 
DEFAULT              : 
DEREFERENCE          : 
DIVIDE               : 
DIVIDE_ASSIGN        : 
DO                   : 
DOT                  : 
DOUBLE               : 
ELSE                 : 
EQ                   : 
EXTERN               : 
FLOAT                : 
FLOAT_NUM            : 
FOR                  : 
FREE                 : 
GE                   : 
GT                   : 
IDENTIFIER           : 1
IF                   : 
INCREMENT            : 
INT                  : 1
LBRACE               : 
LBRACKET             : 
LE                   : 
LONG                 : 
LPAREN               : 
LSHIFT               : 
LT                   : 
MALLOC               : 
MINUS                : 
MINUS_ASSIGN         : 
MODULO               : 
NE                   : 
NOT                  : 
NUMBER               : 1
OR                   : 
PLUS                 : 
PLUS_ASSIGN          : 
PRINTF               : 
QUESTION             : 
RBRACE               : 
RBRACKET             : 
REGISTER             : 
RETURN               : 
RPAREN               : 
RSHIFT               : 
SCANF                : 
SEMICOLON            : 1
SHORT                : 
SIGNED               : 
SIZEOF               : 
STATIC               : 
STRING_LITERAL       : 
SWITCH               : 
TIMES                : 
TIMES_ASSIGN         : 
UNSIGNED             : 
VOID                 : 
VOLATILE             : 
WHILE                : 
error                : 

Nonterminals, with rules where they appear

test                 : 0

Parsing method: LALR

state 0

    (0) S' -> . test
    (1) test -> . INT IDENTIFIER ASSIGN NUMBER SEMICOLON

    INT             shift and go to state 2

    test                           shift and go to state 1

state 1

    (0) S' -> test .



state 2

    (1) test -> INT . IDENTIFIER ASSIGN NUMBER SEMICOLON

    IDENTIFIER      shift and go to state 3


state 3

    (1) test -> INT IDENTIFIER . ASSIGN NUMBER SEMICOLON

    ASSIGN          shift and go to state 4


state 4

    (1) test -> INT IDENTIFIER ASSIGN . NUMBER SEMICOLON

    NUMBER          shift and go to state 5


state 5

    (1) test -> INT IDENTIFIER ASSIGN NUMBER . SEMICOLON

    SEMICOLON       shift and go to state 6


state 6

    (1) test -> INT IDENTIFIER ASSIGN NUMBER SEMICOLON .

    $end            reduce using rule 1 (test -> INT IDENTIFIER ASSIGN NUMBER SEMICOLON .)

